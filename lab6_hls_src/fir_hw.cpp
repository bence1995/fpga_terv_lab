#include "fir.h"

#define N 512

void fir_hw(
		ap_uint<16> tlast_dnum,
		ap_uint<3> smpl_rd_num,
		ap_uint<9> tap_num_m1,
		coeff_t coeff_hw[N],
		din_t *input_l,
		din_t *input_r,
		out_stream_struct *res)
{

///////////////////////////////////////////////////////////////////////////////////
//VARIABLES
///////////////////////////////////////////////////////////////////////////////////

	//Left and Right channel buffer and select
	static din_t buff_l[N];
	static din_t buff_r[N];
	static int lr = 0;
	din_t *input_ptr;
	din_t *buff_ptr;

	//Sample counter
	static ap_uint<16> cntr = 0;

	//Output
	out_stream_struct out_data;

	//TLAST counter
	static ap_uint<16> tlast_cntr = 0;

	//Coefficient pointer
	coeff_t * coeff_ptr;

	//Iterator
	int i;

///////////////////////////////////////////////////////////////////////////////////
//LEFT / RIGHT CHANNELS
///////////////////////////////////////////////////////////////////////////////////

	if(lr == 0)
	{
		lr = 1;
		buff_ptr = buff_l;
		input_ptr = input_l;
	}
	else
	{
		lr = 0;
		buff_ptr = buff_r;
		input_ptr = input_r;
	}

///////////////////////////////////////////////////////////////////////////////////
//SHIFT
///////////////////////////////////////////////////////////////////////////////////

	for_shift: for (i = N; i >= 0; i--)
	{
		buff_ptr[i] = (i == 0) ? *input_ptr : buff_ptr[i - 1];
	}

///////////////////////////////////////////////////////////////////////////////////
//COEFFICIENT BUFFER
///////////////////////////////////////////////////////////////////////////////////

	//ez nem kell
	/*
	if (smpl_rd_num == 4)
	{
		coeff_ptr = coeff_512;
	}
	else
	{
		if (smpl_rd_num == 2)
		{
			coeff_ptr = coeff_256;
		}
		else
		{
			coeff_ptr = coeff_128;
		}
	}
	*/

///////////////////////////////////////////////////////////////////////////////////
//MAC
///////////////////////////////////////////////////////////////////////////////////

	accu_t acc = 0;
	for_mac: for (i = 0; i <= tap_num_m1; i++)
	{
#pragma HLS LOOP_TRIPCOUNT min=128 max=512
		acc = acc + (coeff_hw[i] * buff_ptr[i]);
	}


///////////////////////////////////////////////////////////////////////////////////
//OUTPUT
///////////////////////////////////////////////////////////////////////////////////

	cntr++;

	//LEFT
	if ( (cntr % (smpl_rd_num << 1) ) == 0)
	{
		out_data.tdata = acc;
		tlast_cntr++;
	}

	//RIGHT
	if ( (cntr % (smpl_rd_num << 1) ) == 1)
	{
		out_data.tdata = acc;
		tlast_cntr++;
	}


///////////////////////////////////////////////////////////////////////////////////
//GENERATE TLAST
///////////////////////////////////////////////////////////////////////////////////

	if (tlast_cntr % (tlast_dnum * smpl_rd_num) == 0)
		out_data.tlast = 1;
	else
		out_data.tlast = 0;




	*res = out_data;
}
